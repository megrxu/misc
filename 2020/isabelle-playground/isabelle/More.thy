theory More
  imports Main

begin

(* ex. 2.1 *)

fun double :: "nat \<Rightarrow> nat" where
  "double 0 = 0" |
  "double (Suc m) = Suc (Suc (double m))"

lemma "double m = m + m"
  by (induction m) auto

(* ex. 2.5 *)

fun sum_upto :: "nat \<Rightarrow> nat" where
  "sum_upto 0 = 0" |
  "sum_upto (Suc n) = Suc n + sum_upto n"

lemma "sum_upto n = n * (n + 1) div 2"
  by(induction n) auto

(* ex. 2.6 *)

datatype 'a tree = Tip | Node "'a tree" 'a "'a tree"

fun mirror :: "'a tree \<Rightarrow> 'a tree" where
  "mirror Tip = Tip" |
  "mirror (Node l a r) = Node (mirror r) a (mirror l)"

lemma "mirror (mirror t) = t"
  by (induction t) auto

fun contents :: "'a tree \<Rightarrow> 'a list" where
  "contents Tip = Nil" |
  "contents (Node l a r) = Cons a ((contents l) @ (contents r))"

fun sum_tree :: "nat tree \<Rightarrow> nat" where
  "sum_tree Tip = 0" | 
  "sum_tree (Node l a r) = a + sum_tree r + sum_tree l"

lemma "sum_tree t = sum_list (contents t)"
  by (induction t) auto

(* ex. 2.8 *)

fun intersperse :: "'a \<Rightarrow> 'a list \<Rightarrow> 'a list" where
  "intersperse _ Nil = Nil" |
  "intersperse a (Cons x xs) = [x, a] @ intersperse a xs"

lemma "map f (intersperse a xs) = intersperse (f a) (map f xs)"
  by (induction xs) auto

fun itrev :: "'a list \<Rightarrow> 'a list \<Rightarrow> 'a list" where
  "itrev Nil ys = ys" |
  "itrev (x # xs) ys = itrev xs (x#ys)"

lemma "itrev xs ys = rev xs @ ys"
  by (induction xs arbitrary: ys) auto

(* ex. 2.9 *)

fun itadd :: "nat \<Rightarrow> nat \<Rightarrow> nat" where
  "itadd 0 n = n" |
  "itadd (Suc m) n = Suc (itadd m n)"

lemma "itadd m n = m + n"
  by (induction m arbitrary: n) auto

(* ex. 2.10 *)

datatype tree0 = Tip | Node tree0 tree0

fun nodes :: "tree0 \<Rightarrow> nat" where
  "nodes Tip = 0" |
  "nodes (Node l r) = 1 + nodes l + nodes r"

fun explode :: "nat \<Rightarrow> tree0 \<Rightarrow> tree0" where
  "explode 0 t = t" |
  "explode (Suc n) t = explode n (Node t t)"

lemma "nodes (explode n t) = (1 + nodes t) * 2 ^ n - 1"
  by (induction n arbitrary: t) (auto simp add: algebra_simps)

(* ex. 2.11 *)

datatype exp = Var | Const int | Add exp exp | Mult exp exp

fun eval :: "exp \<Rightarrow> int \<Rightarrow> int" where
  "eval Var x = x" |
  "eval (Const n) x = n" |
  "eval (Add e1 e2) x= eval e1 x + eval e2 x" |
  "eval (Mult e1 e2) x = eval e1 x * eval e2 x"

fun evalp :: "int list \<Rightarrow> int \<Rightarrow> int" where
  "evalp [] v = 0" |
  "evalp (x#xs) v = x + v * (evalp xs v)"

value "evalp [4, 2, -1, 3] 2"

fun list_addition :: "int list \<Rightarrow> int list \<Rightarrow> int list" where
  "list_addition x [] = x" |
  "list_addition [] y = y" |
  "list_addition (x#xs) (y#ys) = Cons (x + y) (list_addition xs ys)"

value "list_addition [4, 2, -1, 3] [1, 2, 3, 4, 5]"

fun list_times :: "int list \<Rightarrow> int \<Rightarrow> int list" where
  "list_times [] _ = []" |
  "list_times (x#xs) n = (x * n)#list_times xs n"

value "list_times [4, 2, -1, 3] 2"

fun list_multiplication :: "int list \<Rightarrow> int list \<Rightarrow> int list" where
  "list_multiplication [] ys = []" |
  "list_multiplication (x#xs) ys = list_addition (list_times ys x) (Cons 0 (list_multiplication xs ys))"

value "list_multiplication [4, 2, -1, 3] [2, 1]"

fun coeffs :: "exp \<Rightarrow> int list" where
  "coeffs Var = [0, 1]" |
  "coeffs (Const n) = [n]" |
  "coeffs (Add e1 e2) = list_addition (coeffs e1) (coeffs e2)" |
  "coeffs (Mult e1 e2) = list_multiplication (coeffs e1) (coeffs e2)"

section \<open>Proving @{term "evalp (coeffs e) x = eval e x"}\<close>

text \<open>How could we prove that @{term "evalp"} behaves similarly to @{term "eval"}? Fortunately, 
Nipkow and Klein have provided the stub for us to prove @{text "evalp_eq_eval"} below. The recursive
style of @{term "evalp"} and @{term "eval"} suggest that we should prove the theorem with induction.

After using @{text "apply (induction e)"} and @{text "apply auto"}, we are left with two goals which 
auto cannot solve. A closer inspection of the difference proof state on the first and the second
application, we know that there are four goals initially and auto discharges the first two. The two 
goals that auto cannot solves belong to the third and the fourth goal generated by 
@{text "apply (induction e)"}. 

It is worth to inspect why auto cannot discharges the third and the fourth goal. The third 
goal looks like this (after auto):
  @{term "\<And>e1 e2. \<lbrakk>evalp (coeffs e1) x = eval e1 x;  evalp (coeffs e2) x = eval e2 x\<rbrakk> \<Longrightarrow> 
                      evalp (list_addition (coeffs e1) (coeffs e2)) x = eval e1 x + eval e2 x"}  (1)
At the first glance, auto cannot solve this goal because of the occurrence of @{term
"list_addition"} which is defined recursively too; auto cannot deal with recursive definition by
itself and we need to supply with intermediate lemma to help auto solve this problem. We then
dedicate our next effort to find a single lemma that will prove this goal. 

What lemma should we prove to help to discharge goal three? I could copy the conclusion of the 
lemma, i.e. 

  @{term "evalp (list_addition (coeffs e1) (coeffs e2)) x = eval e1 x + eval e2 x"}              (2)

and then try to prove this lemma. What proof tactic should we use here? Since the ``core''
expression here is @{term "list_addition"}, we could try @{text "apply (induction rule:
list_addition.induct)"} which means we follow the recursive structure provided by @{term
"list_addition"}. But it immediately shows how absurd this is since the first goal is

  @{term "\<And>xa. evalp [] x = eval e1 x + eval e2 x"} .

This is unprovable --- empty list of coefficient should evaluate to zero, and we do not have 
the guarantee that the RHS is zero. Hence there must be something wrong with Eq.~(2). Indeed, this 
absurdity is because we forgot to include the premises in Eq.~(2). If we use these premises, we 
could come up with a better lemma: 

  @{term "evalp (list_addition (coeffs e1) (coeffs e2)) x = 
                                                         evalp (coeffs e1) x + evalp (coeffs e2) x"}

Now, the @{term "coeffs e1"} and @{term "coeffs e2"} are superfluous; we could just name them 
@{term "xs"} and @{term "ys"} as shown in the Lemma @{text "evalp_list_addition"}:

  @{term "evalp (list_addition xs ys) x = evalp xs x +  evalp ys x"}

which makes totally sense. We shall find this pattern quite often in our career as a proof engineer.
When introducing a new function (or constructor) such as @{term "list_addition"}, we need to define 
its semantics or interpretation. This lemma is exactly how we interpret @{term "list_addition"}: 
this is an addition (as shown in the sign @{term "(+)"}) on the RHS.

Specifying a lemma is only halfway of our journey; we still need to prove it. But before we prove
such lemma, it is a good idea to use two tools in Isabelle to try to disprove a lemma (to see
whether such lemma has a counterexample). We could use `quickcheck' or `nitpick' just below the
lemma. Quickcheck says @{text "Quickcheck found no counterexample."} and nitpick says @{text
"Nitpick ran out of time after checking 5 of 10 scopes"} which are good signs.

How can we prove such lemma? Again, since it is defined recursively, then induction is our friend 
here. After invoking @{text "apply (induction rule:list_addition.induct)"} and @{text "apply auto"}
we are left with one goal: 

@{term "\<And>xs ys. evalp (list_addition xs ys) x = evalp xs x + evalp ys x \<Longrightarrow> 
                                  x * (evalp xs x + evalp ys x) = x * evalp xs x + x * evalp ys x"}

This goal is easy for us --- we only need to apply distributive property. But it seems like auto
does not have this rule built in her knowledge base. We could simply use the `find_theorems' feature
with the pattern "_ * (_ + _) = _ * _ + _ * _". We could choose one, say the rule @{thm
"semiring_class.distrib_left"} by @{text "apply (rule semiring_class.distrib_left)"} which leave no
goals to be proved. But this is ugly style of proof: in general we want auto to be the last proof
tactic we use. It is better to use @{text "apply (auto simp add: semiring_class.distrib_left)"}. Or,
as hinted in the concrete semantics we could use @{text "apply (auto simp add: algebra_simps)"}. To
make the notation is even more compact, we could combine them into one-liner proof with by as
follows. \<close>

lemma evalp_list_addition:
  "evalp (list_addition xs ys) x = evalp xs x +  evalp ys x"
  by (induction rule:list_addition.induct) (auto simp add: algebra_simps)

text \<open>Previous proof effort have given us some insight: we need to provide the interpretation of
@{term "list_addition"}. Likewise, we need to provide interpretations for @{term "list_times"} and
@{term "list_multiplication"}. For @{term "list_times"} is easy and straightforward shown as
follows: \<close>

lemma evalp_list_times:
  "evalp (list_times xs n) x = evalp xs x * n"
  by (induction arbitrary: x rule:list_times.induct) (auto simp add: algebra_simps)

text \<open>Specifying interpretation for @{term "list_multiplication"} is also straightforward but
applying standard proof rule by induction leaves us with one proof goal:

@{term "\<And>xa xs ys.
       evalp (list_multiplication xs ys) x = evalp xs x * evalp ys x \<Longrightarrow>
       evalp (list_addition (list_times ys xa) (0 # list_multiplication xs ys)) x = 
                                                                (xa + x * evalp xs x) * evalp ys x"}

We found the occurrence of @{term "evalp (list_addition term1 term2) term3"} here, which means 
the lemma @{thm "evalp_list_addition"} will help. Then we supplant this lemma in auto by
@{text "apply (auto simp add: evalp_list_addition)"} which leaves us with the following goal:

@{term "\<And>xa xs ys.
       evalp (list_multiplication xs ys) x = evalp xs x * evalp ys x \<Longrightarrow> 
       evalp (list_times ys xa) x + x * (evalp xs x * evalp ys x) = 
                                                                (xa + x * evalp xs x) * evalp ys x"}

Notice the occurrence of @{term "evalp (list_times ys xa) x"}? It asks us to interpret 
@{term "list_times"} which we readily have in @{thm "evalp_list_times"}. We supplant this lemma 
again in auto by @{text "apply (auto simp add: evalp_list_addition evalp_list_times)"} which leaves
us with the following goal:

@{term "\<And>xa xs ys. evalp (list_multiplication xs ys) x = evalp xs x * evalp ys x \<Longrightarrow> 
              evalp ys x * xa + x * (evalp xs x * evalp ys x) = (xa + x * evalp xs x) * evalp ys x"}

This is child's play and we can discharge the whole goal as follows:
\<close>

lemma evalp_list_mult:
  "evalp (list_multiplication xs ys) x = evalp xs x * evalp ys x"
  by(induction rule:list_multiplication.induct)
    (auto simp add: evalp_list_addition evalp_list_times algebra_simps)

text \<open>Proving the final theorem is then very easy as shown below.\<close>

theorem evalp_eq_eval:
  "evalp (coeffs e) x = eval e x"
  by (induction e) (auto simp add: evalp_list_addition evalp_list_mult)

end